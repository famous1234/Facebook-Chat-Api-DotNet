// Generated by CoffeeScript 1.9.3
(function() {
  var CHAT_INIT_PARAMS, CHAT_INIT_URL, CLIENT_CONVERSATION_STATE_LIST, CLIENT_GET_SELF_INFO_RESPONSE, INITIAL_CLIENT_ENTITIES, Init, NetworkError, Q, find, fs, log, ref, ref1, req, request, syspath, uniqfn,
    slice = [].slice;

  request = require('request');

  log = require('bog');

  Q = require('q');

  fs = require('fs');

  syspath = require('path');

  ref = require('./util'), req = ref.req, find = ref.find, uniqfn = ref.uniqfn, NetworkError = ref.NetworkError;

  ref1 = require('./schema'), CLIENT_GET_SELF_INFO_RESPONSE = ref1.CLIENT_GET_SELF_INFO_RESPONSE, CLIENT_CONVERSATION_STATE_LIST = ref1.CLIENT_CONVERSATION_STATE_LIST, INITIAL_CLIENT_ENTITIES = ref1.INITIAL_CLIENT_ENTITIES;

  CHAT_INIT_URL = 'https://talkgadget.google.com/u/0/talkgadget/_/chat';

  CHAT_INIT_PARAMS = {
    prop: 'aChromeExtension',
    fid: 'gtn-roster-iframe-id',
    ec: '["ci:ec",true,true,false]',
    pvt: null
  };

  module.exports = Init = (function() {
    function Init(proxy) {
      this.proxy = proxy;
    }

    Init.prototype.initChat = function(jarstore, pvt) {
      var opts, params;
      params = clone(CHAT_INIT_PARAMS);
      params.pvt = pvt;
      opts = {
        method: 'GET',
        uri: CHAT_INIT_URL,
        qs: params,
        jar: request.jar(jarstore),
        proxy: this.proxy
      };
      return req(opts).then((function(_this) {
        return function(res) {
          if (res.statusCode === 200) {
            return _this.parseBody(res.body);
          } else {
            log.warn('init failed', res.statusCode, res.statusMessage);
            return Q.reject(NetworkError.forRes(res));
          }
        };
      })(this));
    };

    Init.prototype.parseBody = function(body) {
      return Q().then(function() {
        var html, out;
        html = body.replace(/<!DOCTYPE html><html>(.|\n)*<\/html>/gm, '');
        html = html.replace(/<\/?script>/gm, '');
        html = html.replace('var AF_initDataChunkQueue =', 'var AF_initDataChunkQueue = this.AF_initDataChunkQueue =');
        (function() {
          return eval(html);
        }).bind(out = {})();
        return out;
      }).then((function(_this) {
        return function(out) {
          var DICT, allents, d, deduped, ent, entgroups, g, k, safe, spec;
          DICT = {
            apikey: {
              key: 'ds:7',
              fn: function(d) {
                return d[0][2];
              }
            },
            email: {
              key: 'ds:33',
              fn: function(d) {
                return d[0][2];
              }
            },
            headerdate: {
              key: 'ds:2',
              fn: function(d) {
                return d[0][4];
              }
            },
            headerversion: {
              key: 'ds:2',
              fn: function(d) {
                return d[0][6];
              }
            },
            headerid: {
              key: 'ds:4',
              fn: function(d) {
                return d[0][7];
              }
            },
            timestamp: {
              key: 'ds:21',
              fn: function(d) {
                return new Date(d[0][1][4] / 1000);
              }
            },
            self_entity: {
              key: 'ds:20',
              fn: function(d) {
                return CLIENT_GET_SELF_INFO_RESPONSE.parse(d[0]).self_entity;
              }
            },
            conv_states: {
              key: 'ds:19',
              fn: function(d) {
                return CLIENT_CONVERSATION_STATE_LIST.parse(d[0][3]);
              }
            },
            entities: {
              key: 'ds:21',
              fn: function(d) {
                return INITIAL_CLIENT_ENTITIES.parse(d[0]);
              }
            }
          };
          for (k in DICT) {
            spec = DICT[k];
            ent = find(out.AF_initDataChunkQueue, function(e) {
              return spec.key === e.key;
            });
            if (ent) {
              _this[k] = d = spec.fn(ent.data());
              if (d.length) {
                log.debug('init data count', k, d.length);
              } else {
                log.debug('init data', k, d);
              }
            } else {
              log.warn('no init data for', k);
            }
          }
          entgroups = (function() {
            var i, results;
            results = [];
            for (g = i = 1; i <= 5; g = ++i) {
              results.push(this.entities["group" + g].entities);
            }
            return results;
          }).call(_this);
          allents = map(concat.apply(null, [_this.entities.entities].concat(slice.call(entgroups))), function(e) {
            return e.entity;
          });
          safe = allents.filter(function(e) {
            var ref2;
            return e != null ? (ref2 = e.id) != null ? ref2.gaia_id : void 0 : void 0;
          });
          deduped = uniqfn(safe, function(e) {
            return e.id.gaia_id;
          });
          return _this.entities = deduped;
        };
      })(this));
    };

    return Init;

  })();

}).call(this);
